---
title: java编程建议（二）
date: 2017-10-27 20:22:31
tags: java
---
1. 三元操作符的后两个的数据类型应该一致

2. 两个相似的边长方法需小心Null和空值的威胁。导致编译器不知道该调用哪个方法

3. 子类覆写父类的变长方法，应该保证参数列表的形式完全相同

4. 在C++中：`i=i++ `等效于 i++ 。而PHP和Java中`i=i++` ，i会一直等于初值。

5. 在实现Serializable接口时，显示声明serialVersionUID（流标制符号）,可以在分布式部署的应用中，防止因为该实现类的更新同步不及时，导致反序列化出错。

   > 总结：显示声明serialVersionUID可以避免对象不一致，但尽量不要以这种方式向JVM“撒谎”

6. 反序列化时构造函数不会执行，所以**不要在构造函数中对final变量赋值**，应该直接在声明后跟上初始值。而final static 变量不会保存到数据流中。

7. 保存到磁盘上（或网络传输）的对象文件包括两部分： 

  + 类描述信息 包括包路径、继承关系、访问权限、变量描述、变量访问权限、方法签名、返回值，以及变量的关联类信息。要注意的一点是，它并不是class文件的翻版，它不记录方法、构造函数、static变量等的具体实现。之所以类描述会被保存，很简单，是因为能去也能回嘛，这保证反序列化的健壮运行。 
  + 非瞬态（transient关键字）和非静态（static关键字）的实例变量值 注意，这里的值如果是一个基本类型，好说，就是一个简单值保存下来；如果是复杂对象，也简单，连该对象和关联类信息一起保存，并且持续递归下去（关联类也必须实现Serializable接口，否则会出现序列化异常），也就是说递归到最后，其实还是基本数据类型的保存。

8. 总结一下，反序列化时final变量在以下情况下不会被重新赋值:

    + 通过**构造函数**为final变量赋值。 
    + 通过**方法返回值**为final变量赋值。
    + final修饰的属性不是基本类型。

9. 不使用transient，更好的解决**部分属性持久化问题**的方法：使用序列化回调机制。

   >  Java调用ObjectOutputStream类把**一个对象转换成流数据时**，会通过反射（Reflection）检查被序列化的类是否有writeObject方法(要求：私有、无返回值)。
   >
   >  若有，则会委托该方法进行对象序列化;
   >
   >  若没有，则由ObjectOutputStream按照默认规则继续序列化。
   >
   >  同样，在**从流数据恢复成实例对象时**，也会检查是否有一个私有的readObject方法，如果有，则会通过该方法读取属性值。

10. + instanceof : 只要左右两个操作数有继承或实现关系，就可以编译通过，比如：`new Object() instanceof String `。 
    + instanceof 只能用于对象的判断，**不能用于基本类型的判断**，因此：`'A'instanceof Character `编译不通过。
  + 若左操作数是Null，结果直接返回false。这对我们编程有利，**使用istanceof时不用关心左操作数是否为null**，这与我们经常用到的equals、toString方法不同

11. + 对于final修饰的基本类型和String类型，编译器会认为它是稳定态（Immutable Status），所以在编译时就直接把值编译到字节码中了，避免了在运行期引用（Run-time Reference），以提高代码的执行效率。
    + 而对于final修饰的类（即非基本类型），编译器认为它是不稳定态（Mutable Status），在编译时建立的则是引用关系（该类型也叫做Soft Final），如果Client类引入的常量是一个类或实例，即使不重新编译也会输出最新值。

12. 用偶判断，不用奇判断。
    + `String str=i+"-＞"+（i%2==1?"奇数"："偶数"）； System.out.println（str）；`

      **当输入-1 时： -1-＞偶数**  

      + 修改办法：i%2==0?"偶数"："奇数"

    + 我们先来了解一下Java中的取余（%标示符）算法，模拟代码如下：

      ```c
      //模拟取余计算，dividend被除数，divisor除数 
      public static int remainder（int dividend, int divisor）{ 
      	return dividend-dividend/divisor*divisor； }
      ```

13. 处理货币数字交易时:
    + 使用BigDecimal BigDecimal是专门为弥补浮点数无法精确计算的缺憾而设计的类，并且它本身也提供了加减乘除的常用数学算法。特别是与数据库Decimal类型的字段映射时，BigDecimal是最优的解决方案。 
    + 使用整型 把参与运算的值扩大100倍，并转变为整型，然后在展现时再缩小100倍，这样处理的好处是计算简单、准确，一般在非金融行业（如零售行业）应用较多。此方法还会用于某些零售POS机，它们的输入和输出全部是整数，那运算就更简单。

14. 基本类型的包装对象的**拆箱过程**存在着问题。包装对象和拆箱对象可以自由转换，这不假，但是**要剔除null值**，null值并不能转化为基本类型。

    > 对于此类问题，我们谨记一点：包装类型参与运算时，要做null值校验。

15. 整型池：

    cache是IntegerCache内部类的一个静态数组，容纳的是-128到127之间的Integer对象。

    + 通过valueOf**产生包装对象时**，如果int参数在-128和127之间，则直接从整型池中获得对象(提高空间和时间性能)

    + **不在该范围的**int类型则通过new生成包装对象。

    + ```
      static final Integer cache[]=new Integer[-（-128）+127+1]；
      static{
          for（int i=0；i＜cache.length；i++）
          	cache[i]=new Integer（i-128）；
      }
      ```


16. **自动装箱**有一个重要的原则：基本类型可以先加宽，再转变成宽类型的包装类型，但不能直接转变成宽类型的包装类型。这句话比较拗口，举例：int可以加宽转变成long，然后再转变成**Long对象**，但int不能直接转变成long对象，注意这里指的都是**自动转换**，不是通过构造函数生成。
17. 获取随机数，不要随便设置随机种子。通常使用Math.random方法或Random类来获得随机数。比如： `Random r= new Random(1000); r.nextInt();`
    + 在Java中，随机数的产生取决于种子，随机数和种子之间的关系遵从以下两个规则：
    + + 种子不同，产生不同的随机数。 
    + + 种子相同，即使实例不同也产生相同的随机数。
    + Random类的默认种子（无参构造）是`System.nanoTime()`的返回值（JDK 1.5版本以前默认种子是`System.currentTimeMillis()`的返回值）
    + `new Random（1000）`显式地设置了随机种子为1000，运行多次，虽然实例不同，但都会获得相同的三个随机数。所以，**除非必要，否则不要设置随机种子**。
18. **静态变量一定要先声明后赋值**
    + 从静态变量的诞生说起，静态变量是类加载时被分配到数据区（Data Area）的，它在内存中只有一个拷贝，不会被分配多次，其后的所有赋值操作都是值改变，地址则保持不变。我们知道JVM初始化变量是先声明空间，然后再赋值的。
    + 静态变量是在类初始化时首先被加载的，JVM会去查找类中所有的静态声明，然后分配空间，注意这时候只是完成了地址空间的分配，还没有赋值，之后JVM会根据类中静态赋值（包括静态类赋值和静态块赋值）的先后顺序来执行。
    + + eg: 对于程序来说，就是先声明了int类型的地址空间，并把地址传递给了i，然后按照类中的先后顺序执行赋值动作，首先执行静态块中i=100，接着执行i=1，那最后的结果就是i=1了。